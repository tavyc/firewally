#!/bin/bash
# -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
# File:	       firewally
# Description: FireWally: Easy, Advanced Zone-Based Firewall
#
# Copyright:   Copyright (C) 2004 yLabs
# Part of:     firewally
# Author:      Octavian Cerna <tavy@ylabs.com>
# Id:	       $Id$
# -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

# {{{ Bash version check

case "$BASH_VERSION" in
    1.*)
	echo >&2 "firewally: FATAL: This program requires GNU bash 2.x"
	exit 1
	;;
esac

# }}}

# {{{ Global Variables

shopt -s extglob

# Version
FIREWALLY_VERSION='1.5'
FIREWALLY_REVISION='$Id$'
_FWY_CONFIG_VERSION=1

# Basic options
: "${FIREWALLY_CONFIG:=/etc/firewally/firewall.conf}"
: "${FIREWALLY_USE_MPORT:=}"
: "${FIREWALLY_MPORT_MATCH:=}"
: "${FIREWALLY_USE_IPTABLES_RESTORE:=1}"
FIREWALLY_STATEFUL=1
FIREWALLY_ROUTING=1
FIREWALLY_MODULES="all"
FIREWALLY_UNCONFIGURED=

# Default policies
FIREWALLY_filter_INPUT_POLICY="drop loglimit"
FIREWALLY_filter_OUTPUT_POLICY="accept"
FIREWALLY_filter_FORWARD_POLICY="drop loglimit"
FIREWALLY_filter_unroutable_POLICY="drop loglimit"
FIREWALLY_filter_mac_invalid_POLICY="drop loglimit"
FIREWALLY_SYNFLOOD_LIMIT=50/second
FIREWALLY_ICMPFLOOD_LIMIT=20/second

# Logging options
FIREWALLY_LOG_TEXT='FW: ${chain}${action:+ $action}${text:+ $text}: '
FIREWALLY_LOG_TEXT_TRUNC='FW: ${chain//_to_/2}${action:+ $action}: '
FIREWALLY_LOG_LEVEL="notice"
FIREWALLY_LOG_FREQUENCY="1/second"
FIREWALLY_LOG_BURST="2"
FIREWALLY_LOG_OPTIONS=""

# Utils
# IANA Reserved IPv4 address space
RESERVED_IPS="0.0.0.0/7 2.0.0.0/8 5.0.0.0/8 7.0.0.0/8 23.0.0.0/8 27.0.0.0/8 31.0.0.0/8 36.0.0.0/7 39.0.0.0/8 42.0.0.0/8 49.0.0.0/8 50.0.0.0/8 92.0.0.0/6 96.0.0.0/4 112.0.0.0/5 120.0.0.0/8 127.0.0.0/8 173.0.0.0/8 174.0.0.0/7 176.0.0.0/5 184.0.0.0/6 192.0.2.0/24 197.0.0.0/8 198.18.0.0/15 223.0.0.0/8 240.0.0.0/4"
# Private IPv4 address space
PRIVATE_IPS="10.0.0.0/8 172.16.0.0/12 169.254.0.0/16 192.168.0.0/16 192.88.99.0/24"
# The multicast address space
MULTICAST_IPS="224.0.0.0/4"
# All the Internet unroutable addresses
UNROUTABLE_IPS="${PRIVATE_IPS} ${RESERVED_IPS}"
# Safe/unsafe ICMP messages
SAFE_ICMP="echo-reply,destination-unreachable,source-quench,echo-request,time-exceeded,parameter-problem"
UNSAFE_ICMP="redirect,router-advertisement,router-solicitation,timestamp-request,timestamp-reply,address-mask-request,address-mask-reply"

# Internal state
_FWY_MODE=
_FWY_VERBOSE=
_FWY_TMP=
_FWY_LINENO=
_FWY_USING_IPTABLES=
_FWY_COMMAND=
_FWY_TABLE=filter
_FWY_CHAIN=INPUT
_FWY_DYN_CHAIN=1
_FWY_RULES_INIT=1
_FWY_RULES_MAC=2
_FWY_RULES_ZONE_ANY1=3
_FWY_RULES_ZONE_ANY2=4
_FWY_RULES_ZONE_SEL=5
_FWY_RULES_USER=6
_FWY_RULES_POLICY=7
_FWY_RULES=
_FWY_ZONES=
_FWY_ZONES_INIT=

# }}}

# {{{ Services

# Syntax: proto/[port[:port]][,...] ...

service_ah="ah/"
service_aol="tcp/5190:5193"
service_apcupsd="tcp/6544"
service_apcupsdnis="tcp/3551"
service_aptproxy="tcp/9999"
service_bittorrent="tcp/6881:6999"
service_bootps="udp/67"
service_coda="tcp/369:370,2430:2433 udp/369:370,2430:2433"
service_cups="tcp/631"
service_cvspserver="tcp/2401"
service_dcpp="tcp/1412 udp/1412"
service_dhcps="udp/67"
service_directplay="tcp/47624,2300:2400 udp/6073,2300:2400"
service_dns="udp/53 tcp/53"
service_edonkey="tcp/4661:4662 udp/4672,4665"
service_esp="esp/"
service_gre="gre/"
service_halflife="udp/27010:27020"
service_heartbeat="udp/690:699"
service_heretic2="udp/28910"
service_hexen2="udp/26900"
service_icmp="icmp/any"
service_icp="udp/3130"
service_icq="tcp/5190:5193 udp/4000"
service_ident="tcp/113"
service_igmp="igmp/"
service_ipencap="4/"
service_ipsec="esp/ ah/ udp/500"
service_irc="tcp/6666:6669"
service_isakmp="udp/500"
service_isis="isis/"
service_jabber="tcp/5222:5223"
service_jabberd="tcp/5222:5223,5269"
service_lpd="tcp/printer"
service_msn="tcp/6891"
service_netbios_dgm="udp/138"
service_netbios_ns="udp/137"
service_nfs="tcp/2049 udp/2049"
service_ntp="udp/123"
service_openmosix="tcp/723,4660 udp/5428,32768"
service_oracle="tcp/1521,1525"
service_ospf="ospf/"
service_pcanywhere="tcp/5631 udp/5632"
service_pim="pim/"
service_ping="icmp/echo-request"
service_portmap="udp/111 tcp/111"
service_postgres="tcp/5432"
service_pptp="tcp/1723 gre/"
service_privoxy="tcp/8118"
service_quake2="udp/27910"
service_quake3="udp/27960"
service_quake="tcp/26000 udp/26000"
service_radius="udp/1812,1813"
service_radiusold="udp/1645:1646"
service_realaudio="tcp/7060,554 udp/554,8554"
service_rip="udp/520"
service_rsvp="rsvp/"
service_samba="tcp/139,445 udp/137:138"
service_skip="skip/"
service_smtps="tcp/465"
service_snmp="udp/161"
service_snmptrap="udp/162"
service_socks="tcp/1080 udp/1080"
service_squid="tcp/3128"
service_ssdp="udp/1900"
service_submission="tcp/587"
service_syslog="udp/514"
service_talk="udp/517:518"
service_tftp="udp/69"
service_time="tcp/37 udp/37"
service_tinc="tcp/655 udp/655"
service_traceroute="udp/33434:33524"
service_upnp="tcp/5000 udp/1900,5000"
service_vmware="tcp/902"
service_vmwareauth="tcp/903"
service_vmwareweb="tcp/8222"
service_vnc="tcp/5900:5903"
service_vnc_http="tcp/5800:5803"
service_vrrp="vrrp/"
service_webmin="tcp/10000"
service_winterm="tcp/3389"
service_x11="tcp/6000:6009"
service_xdmcp="udp/177"
service_xfs="tcp/7100"
service_ymsgr="tcp/5050,5000:5010,5100:5101 udp/5000:5010"
service_ygames="11000:12000"

service_allirc="tcp/6660:6670,7000:7010"
service_allmail="tcp/25,465,587,110,143,995,993"
service_allpop="tcp/110,143,995,993"
service_allsmtp="tcp/25,465,587"
service_allweb="tcp/80,443"
service_cstrike="$service_halflife"
service_emule="$service_edonkey"
service_ipip="$service_ipencap"
service_safeicmp="icmp/$SAFE_ICMP"
service_sunrpc="$service_portmap"

# }}}

# {{{ Utils

# _fwy_find_cmd var command
# Find a program in $PATH. Set var to the full path of command.
_fwy_find_cmd()
{
    local var=$1
    shift
    local -a cmd=(`type -a -p "$@"`)
    [ $? -ne 0 -o ! -x "${cmd[0]}" ] && _fwy_fatal "Program '$1' not found in system path ($PATH)"
    eval "$var=\"\${cmd[0]}\""
}

# _fwy_verbose args...
_fwy_verbose()
{
    if [ -n "$_FWY_VERBOSE" ]; then
	echo " $@"
    elif [ "$_FWY_MODE" = explain ]; then
	echo "# $@"
    fi
}

# _fwy_warning args...
_fwy_warning()
{
    echo >&2
    echo >&2 "firewally: Warning: $@"
    if [ -z "$FIREWALLY_SIMPLE_ERRORS" ]; then
	[ -n "$_FWY_COMMAND" ] && echo >&2 "        in command: ${_FWY_COMMAND}"
	[ -n "$_FWY_LINENO" ] && echo >&2 "            source: ${FIREWALLY_CONFIG}:${_FWY_LINENO}"
    fi
    return 0
}

# _fwy_error args...
_fwy_error()
{
    echo >&2
    echo >&2 "firewally:   ERROR: $@"
    if [ -z "$FIREWALLY_SIMPLE_ERRORS" ]; then
	[ -n "$_FWY_COMMAND" ] && echo >&2 "        in command: ${_FWY_COMMAND}"
	[ -n "$_FWY_LINENO" ] && echo >&2 "            source: ${FIREWALLY_CONFIG}:${_FWY_LINENO}"
    fi
    [ "$_FWY_MODE" != debug ] && ${_FWY_LOGGER_CMD} -t firewally -p local5.err \
	"$@${_FWY_LINENO:+ at $FIREWALLY_CONFIG:$_FWY_LINENO}${_FWY_COMMAND:+ in command $_FWY_COMMAND}"
    if [ "$_FWY_MODE" != explain -a -z "$_FWY_USING_IPTABLES" ]; then
	enable exit
	exit 1
    fi
    return 0
}

# _fwy_fatal args...
_fwy_fatal()
{
    echo >&2
    echo >&2 "firewally:   FATAL: $@"
    if [ -z "$FIREWALLY_SIMPLE_ERRORS" ]; then
	[ -n "$_FWY_COMMAND" ] && echo >&2 "        in command: ${_FWY_COMMAND}"
	[ -n "$_FWY_LINENO" ] && echo >&2 "            source: ${FIREWALLY_CONFIG}:${_FWY_LINENO}"
    fi
    ${_FWY_LOGGER_CMD} -t firewally -p local5.crit "$@${_FWY_LINENO:+ at $FIREWALLY_CONFIG:$_FWY_LINENO}${_FWY_COMMAND:+ in command $_FWY_COMMAND}"
    enable exit
    exit 2
}

# _fwy_iptables_save args...
# Fix some iptables-save bugs
_fwy_iptables_save()
{
    ${_FWY_IPTABLES_SAVE_CMD} "$@" | \
	${_FWY_AWK_CMD} '{ print gensub(/(--([ugps]id|cmd)-owner) !/, "! \\1 ", "g") }'
    return ${PIPESTATUS[0]}
}

# _fwy_valid_name object name maxlen
_fwy_valid_name()
{
    local object="$1" name="$2" maxlen="$3"

    if [ "${#name}" -gt "$maxlen" ]; then
	_fwy_error "$object name too long: '$name'"
	return 1
    fi
    case "$name" in
	+([a-zA-Z0-9_]))
	    ;;
	*)
	    _fwy_error "invalid $object name: '$name'"
	    return 1
	    ;;
    esac
    return 0
}

# _fwy_match_exists name
_fwy_match_exists()
{
    local name="$1"
    local moddir="/lib/modules/$(uname -r)/kernel/net/ipv4/netfilter"

    ${_FWY_IPTABLES_CMD} -m "$name" --help >/dev/null 2>&1 || return 1
    [ -n "`${_FWY_AWK_CMD} \"/^${name}\$/ { print }\" /proc/net/ip_tables_matches 2>/dev/null`" ] && return 0
    [ -s "$moddir/ipt_${name}.ko" -o -s "$moddir/ipt_${name}.o" ] && return 0
    return 1
}

# }}}

# {{{ Chain Handling

# _fwy_chain_builtin chain
# Return true if chain is a builtin chain
_fwy_chain_builtin()
{
    case "$1" in
	INPUT | FORWARD | OUTPUT | PREROUTING | POSTROUTING)
	    return 0
	    ;;
    esac
    return 1
}

# _fwy_chain_exists chain
# Return true if a chain exists in the current table
_fwy_chain_exists()
{
    [ -d "${_FWY_TMP}/fw/${_FWY_TABLE}/$1" ]
}

# _fwy_create_chain chain
# Create a new chain in the current table and set the default policy
_fwy_create_chain()
{
    local chain="$1" policyvar

    ${_FWY_MKDIR_CMD} -p "${_FWY_TMP}/fw/$_FWY_TABLE/$chain" || \
	_fwy_fatal "cannot create chain '$chain' in table '$_FWY_TABLE'"

    # Set default policy
    policyvar="FIREWALLY_${_FWY_TABLE}_${chain}_POLICY"
    if [ -n "${!policyvar}" ]; then
	# @@@ debug
	[ -f "${_FWY_TMP}/fw/$_FWY_TABLE/$chain/r${_FWY_RULES_POLICY}" ] && _fwy_fatal "policy already defined?"
	local _FWY_CHAIN="$chain" _FWY_RULES=$_FWY_RULES_POLICY
	_fwy_rule ${!policyvar} || return 1
    else
	${_FWY_TOUCH_CMD} "${_FWY_TMP}/fw/$_FWY_TABLE/$chain/r${_FWY_RULES_POLICY}"
    fi
    return 0
}

# }}}

# {{{ Firewall Handling

# _fwy_initialize
# Create the initial firewall structure
_fwy_initialize()
{
    local _FWY_RULES=$_FWY_RULES_INIT _FWY_COMMAND= _FWY_LINENO=

    _fwy_verbose "Initializing"

    _FWY_TABLE=filter
    _FWY_CHAIN=INPUT

    _fwy_create_chain INPUT
    _fwy_create_chain OUTPUT
    _fwy_create_chain FORWARD

    if [ "${FIREWALLY_STATEFUL:-0}" != 0 ]; then
	_fwy_verbose "Creating stateful firewall"
	# Add the establied rule
	for _FWY_CHAIN in INPUT FORWARD OUTPUT; do
	    _fwy_iptables -m state --state ESTABLISHED,RELATED -j ACCEPT
	done
    fi
    # Allow traffic from/to loopback
    _FWY_CHAIN=OUTPUT
    _fwy_iptables -o lo -j ACCEPT
    _FWY_CHAIN=INPUT
    _fwy_iptables -i lo -j ACCEPT

    return 0
}

# _fwy_clear table policy [allow_ip]
# Clear a table from the running firewall
_fwy_clear()
{
    local table="$1" policy="$2" allow_ip="$3"
    local -a table_arg=()

    [ -n "$table" ] && table_arg=("-t" "$table")
    _fwy_iptables_save "${table_arg[@]}" | \
	${_FWY_AWK_CMD} '
/^\*/ { table = substr($1,2); print }
/^:/ {
    if ($2 != "-") {
	if (table == "filter") $2 = policy
	else $2 = "ACCEPT"
	$3 = "[0:0]";
	print
    }
    if (allow && table == "filter") {
	chain = substr($1,2);
	if (chain == "INPUT") print "-A " chain " -s " allow " -j ACCEPT";
        if (chain == "OUTPUT") print "-A " chain " -d " allow " -j ACCEPT";
    }
}
/^COMMIT/ { print }
' policy="$policy" allow="$allow" | \
	${_FWY_IPTABLES_RESTORE_CMD}
    return $[ ${PIPESTATUS[0]} + ${PIPESTATUS[1]:-0} + ${PIPESTATUS[2]:-0} ]
}

# _fwy_load_restore
# Use iptables-restore to load the firewall
_fwy_load_restore()
{
    local table

    # Load rules
    ${_FWY_IPTABLES_RESTORE_CMD} < "${_FWY_NEW_FW}" >/dev/null 2>&1 || return 1

    # Success, clear unused tables
    for table in $(</proc/net/ip_tables_names); do
	if [ ! -d "${_FWY_TMP}/fw/$table" ]; then
	    _fwy_clear "$table" ACCEPT || return 1
	fi
    done
    return 0
}

# _fwy_load_iptables
# Use iptables commands to load the firewall
_fwy_load_iptables()
{
    local table tabledir chain chaindir chainfile rule
    local _FWY_USING_IPTABLES=1 _FWY_LINENO

    # Flush tables
    for tabledir in "${_FWY_TMP}/fw"/*; do
	table="${tabledir##*/}"
	${_FWY_IPTABLES_CMD} -t "$table" -F || return 1
	${_FWY_IPTABLES_CMD} -t "$table" -X || return 1
    done

    # Create chains / set policies
    for chaindir in "${_FWY_TMP}/fw"/*/*; do
	table="${chaindir%/*}"
	table="${table##*/}"
	chain="${chaindir##*/}"
	if _fwy_chain_builtin "$chain"; then
	    ${_FWY_IPTABLES_CMD} -t "$table" -P "$chain" ACCEPT || return 1
	else
	    ${_FWY_IPTABLES_CMD} -t "$table" -N "$chain" || return 1
	fi
    done

    # Load rules
    for chainfile in "${_FWY_TMP}/fw"/*/*/r*; do
	chaindir="${chainfile%/*}"
	table="${chaindir%/*}"
	table="${table##*/}"
	chain="${chaindir##*/}"
	while read rule; do
	    case "$rule" in
		"# source:"*)
		    _FWY_LINENO="${rule##*:}"
		    ;;
		-*)
		    if ! eval "${_FWY_IPTABLES_CMD} -t $table $rule"; then
			_fwy_error "command failed: ${_FWY_IPTABLES_CMD} -t $table $rule"
			return 1
		    fi
	    esac
	done < "$chainfile"
    done

    # Success, clear unused tables
    for table in $(</proc/net/ip_tables_names); do
	if [ ! -d "${_FWY_TMP}/fw/$table" ]; then
	    _fwy_clear "$table" ACCEPT || return 1
	fi
    done

    return 0
}

# }}}

# {{{ Rule Generation

# _fwy_iptables args...
# Add a rule to the current chain
_fwy_iptables()
{
    echo "-A $_FWY_CHAIN $@" >> "${_FWY_TMP}/fw/$_FWY_TABLE/$_FWY_CHAIN/r$_FWY_RULES" || \
    	_fwy_fatal "error writing chain rules"

    if [ "$_FWY_MODE" = explain ]; then
	echo "iptables -t $_FWY_TABLE -A $_FWY_CHAIN $@  # $_FWY_RULES"
    fi
}

# _fwy_rule args...
# Generate rules according to args
# The heart of FireWally
_fwy_rule()
{
    # Variables
    local arg var val svc base_cmd
    local iface=any ifacenot aiface iface_arg
    local oface=any ofacenot aoface oface_arg
    local src=any srcnot asrc src_arg
    local dst=any dstnot adst dst_arg
    local proto=any protonot aproto proto_arg
    local srcport=any srcportnot asrcport srcport_arg
    local dstport=any dstportnot adstport dstport_arg
    local icmptype=any icmptypenot aicmptype icmptype_arg
    local mac=any macnot amac mac_arg
    local mark=any marknot amark mark_arg
    local dscp=any dscpnot adscp dscp_arg
    local tos=any tosnot atos tos_arg
    local state=any state_arg
    local service=any servicenot aservice services=any
    local limit limit_burst limit_arg
    local match
    local log log_match log_args
    local action action_args action_is_chain
    local -a args ports

    # Parse arguments
    while [ $# -gt 0 ]; do
	arg=
	case "$1" in
	    if | iface | inface | interface | input-interface)
		arg=iface
		;;
	    of | oface | outface | outerface | output-interface)
		arg=oface
		;;
	    src | sour | source | saddr | srcaddr | source-address)
		arg=src
		;;
	    dst | dest | destination | daddr | dstaddr | destination-address)
		arg=dst
		;;
	    prot | proto | protocol)
		arg=proto
		;;
	    srcport | sport | source-port)
		case "$protonot$proto" in
		    tcp | udp | "tcp udp" | "udp tcp") ;;
		    *) _fwy_error "parameter '$1' is incompatible with proto '${protonot:+not }$proto'"
		       return 1
		       ;;
		esac
		arg=srcport
		;;
	    dstport | dport| destination-port)
		case "$protonot$proto" in
		    tcp | udp | "tcp udp" | "udp tcp") ;;
		    *) _fwy_error "parameter '$1' is incompatible with proto '${protonot:+not }$proto'"
		       return 1;;
		esac
		arg=dstport
		;;
	    icmptype | icmp-type)
		case "$protonot$proto" in
		    icmp) ;;
		    *) _fwy_error "parameter '$1' is incompatible with proto '${protonot:+not }$proto'"
		       return 1;;
		esac
		arg=icmptype
		;;
	    service | svc)
		[ "$service" != any ] && _fwy_warning "overriding parameter: service '$service' becomes '$2'"
		[ "$proto" != any ] && _fwy_warning "overriding parameter: service overrides proto '$proto'"
		[ "$dstport" != any ] && _fwy_warning "overriding parameter: service overrides dstport '$dstport'"
		[ "$dstport" != any ] && _fwy_warning "overriding parameter: service overrides icmptype '$icmptype'"
		if [ "$2" = not ]; then
		    servicenot=1
		    shift
		fi
		service="${2//[,;]/ }"
		local svc_tcp svc_udp svc_icmp svc_other
		for aservice in $service; do
		    var="service_${aservice//-/_}"
		    svc="${!var}"
		    [ -z "$svc" ] && svc="$aservice"
		    for val in $svc; do
			case "$val" in
			    tcp/* | TCP/*) svc_tcp="${svc_tcp},${val#*/}";;
			    udp/* | UDP/*) svc_udp="${svc_udp},${val#*/}";;
			    icmp/* | ICMP/*) svc_icmp="${svc_icmp},${val#*/}";;
			    */*) svc_other="${svc_other} $val";;
			    *) svc_tcp="${svc_tcp},$val";;
			esac
		    done
		done
		services="${svc_tcp:+tcp/$svc_tcp} ${svc_udp:+udp/$svc_udp} ${svc_icmp:+icmp/$svc_icmp} $svc_other"
		shift
		;;
	    state)
		[ "$state" != any ] && _fwy_warning "overriding parameter: state '$state' becomes '$2'"
		state="$2"
		shift
		;;
	    limit)
		[ -n "$limit" ] && _fwy_warning "overriding parameter: limit '$limit' becomes '$2'"
		limit="$2"
		shift
		if [ "$1" = burst ]; then
		    limit_burst="$2"
		    shift
		fi
		;;
	    mac | mark | dscp | tos)
		arg="$1"
		;;
	    match)
		match="$match $2"
		shift
		;;
	    log | loglimit | log-limit)
		local log_arg="$1" text="$2" log_text= log_level=
		local table="$_FWY_TABLE" chain="$_FWY_CHAIN"

		shift
		if [ "$1" = level ]; then
		    log_level="$2"
		    shift
		fi
		case "$text" in
		    *[\"\\]*)
			_fwy_error "invalid parameter for '$log_arg': quotes and backslashes are not allowed"
			return 1
			;;
		esac
		[ "$action" = LOG -o -n "$log" ] && _fwy_warning "ignoring parameter: '$log_arg'" && continue
		# Set log_text
		eval "log_text=\"${FIREWALLY_LOG_TEXT}\""
		if [ "${#log_text}" -gt 29 ]; then
		    eval "log_text=\"${FIREWALLY_LOG_TEXT_TRUNC}\""
		    [ "${#log_text}" -gt 29 ] && log_text="${log_text:1:29}"
		fi
		if [ -n "$action" ]; then
		    # as logging option
		    log="LOG"
		    log_match=
		    [ "$log_arg" != log ] && \
			log_match="-m limit --limit $FIREWALLY_LOG_FREQUENCY --limit-burst $FIREWALLY_LOG_BURST"
		    log_args="--log-prefix \"$log_text\" --log-level ${log_level:-${FIREWALLY_LOG_LEVEL}} $FIREWALLY_LOG_OPTIONS"
		else
		    # as action
		    action="LOG"
		    action_args="--log-prefix \"$log_text\" --log-level ${log_level:-${FIREWALLY_LOG_LEVEL}} $FIREWALLY_LOG_OPTIONS"
		    log=
		    log_match=
		    log_args=
		    if [ "$log_arg" != log ]; then
			[ -n "$limit" ] && _fwy_warning "overriding parameter: limit '$limit' becomes '$FIREWALLY_LOG_FREQUENCY'"
			limit="$FIREWALLY_LOG_FREQUENCY"
			limit_burst="$FIREWALLY_LOG_BURST"
		    fi
		fi
		;;
	    accept)
		[ -n "$action" ] && _fwy_warning "overriding parameter: action '$action' becomes '$1'"
		action=ACCEPT
		;;
	    drop)
		[ -n "$action" ] && _fwy_warning "overriding parameter: action '$action' becomes '$1'"
		action=DROP
		;;
	    return | ret)
		[ -n "$action" ] && _fwy_warning "overriding parameter: action '$action' becomes '$1'"
		action=RETURN
		;;
	    queue)
		[ -n "$action" ] && _fwy_warning "overriding parameter: action '$action' becomes '$1'"
		action=QUEUE
		;;
	    jump | goto)
		[ -n "$action" ] && _fwy_warning "overriding parameter: action '$action' becomes '$1'"
		[ "$2" = to ] && shift
		if [ -n "$2" ]; then
		    _fwy_valid_name chain "$2" 20 || return 1
		fi
		action="$2" action_is_chain=1
		shift
		;;
	    reject)
		[ -n "$action" ] && _fwy_warning "overriding parameter: action '$action' becomes '$1'"
		action=REJECT
		if [ "$2" = with ]; then
		    shift
		    [ -n "$2" ] && action_args="--reject-with $2"
		    shift
		fi
		;;
	    snat)
		[ -n "$action" ] && _fwy_warning "overriding parameter: action '$action' becomes '$1'"
		[ "$2" = to ] && shift
		if [ -n "$2" ]; then
		    action=SNAT
		    for v in ${2//[,;]/ }; do
			action_args="$action_args --to-source $v"
		    done
		fi
		shift
		;;
	    dnat)
		[ -n "$action" ] && _fwy_warning "overriding parameter: action '$action' becomes '$1'"
		[ "$2" = to ] && shift
		if [ -n "$2" ]; then
		    action=DNAT
		    for v in ${2//[,;]/ }; do
			action_args="$action_args --to-destination $v"
		    done
		fi
		shift
		;;
	    masq | masquerade)
		[ -n "$action" ] && _fwy_warning "overriding parameter: action '$action' becomes '$1'"
		action=MASQUERADE
		;;
	    redirect)
		[ -n "$action" ] && _fwy_warning "overriding parameter: action '$action' becomes '$1'"
		action=REDIRECT
		[ "$2" = to ] && shift
		[ -n "$2" ] && action_args="--to-ports $2"
		shift
		;;
	    setmark)
		[ -n "$action" ] && _fwy_warning "overriding parameter: action '$action' becomes '$1'"
		if [ -n "$2" ]; then
		    action=MARK
		    action_args="--set-mark $2"
		fi
		shift
		;;
	    settos)
		[ -n "$action" ] && _fwy_warning "overriding parameter: action '$action' becomes '$1'"
		if [ -n "$2" ]; then
		    action=TOS
		    action_args="--set-tos $2"
		fi
		shift
		;;
	    setdscp)
		[ -n "$action" ] && _fwy_warning "overriding parameter: action '$action' becomes '$1'"
		if [ -n "$2" ]; then
		    action=DSCP
		    action_args="--set-dscp $2"
		fi
		shift
		;;
	    imq)
		[ -n "$action" ] && _fwy_warning "overriding parameter: action '$action' becomes '$1'"
		if [ "$2" = to ]; then
		    shift
		    if [ -n "$2" ]; then
			action=IMQ
			action_args="--todev $2"
		    fi
		    shift
		else
		    action=IMQ
		fi
		;;
	    target)
		[ -n "$action" ] && _fwy_warning "overriding parameter: action '$action' becomes '$2'"
		if [ -n "$2" ]; then
		    args=($2)
		    action="${args[0]}"
		    action_args="${args[*]:1}"
		fi
		shift
		;;
	    *)
		_fwy_error "unknown argument '$1'"
		return 1
		;;
	esac
	if [ -n "$arg" ]; then
	    if [ "$2" = not ]; then
		shift
		args=(${2//[,;]/ })
		if [ "${#args[@]}" -eq 1 ]; then
		    val="!${args[0]}"
		else
		    val="${args[*]}"
		    eval "${arg}not=1"
		fi
	    else
		val="${2//[,;]/ }"
	    fi
	    [ "${!arg}" != any ] && _fwy_warning "overriding parameter: $arg '${!arg}' becomes '$val'"
	    eval "$arg=\"\$val\""
	    shift
	fi
	shift
    done

    # Done if no action
    [ -z "$action" ] && return 0

    # Initialize if not done already
    [ -d "${_FWY_TMP}/fw" ] || _fwy_initialize

    # Create target chain
    if [ -n "$action_is_chain" ] && ! _fwy_chain_exists "$action"; then
	_fwy_create_chain "$action" || return 1
    fi

    # Record the location of the rules
    if [ -n "${_FWY_LINENO}" ]; then
	echo -e "#\n# source: ${FIREWALLY_CONFIG}:${_FWY_LINENO}\n# $_FWY_COMMAND" \
	    >> "${_FWY_TMP}/fw/$_FWY_TABLE/$_FWY_CHAIN/r$_FWY_RULES"
    fi

    # Replace srcport with mport if appropriate
    if [ "${FIREWALLY_USE_MPORT:-0}" != 0 -a "$srcport" != any ]; then
	ports=($srcport)
	if [ "${#ports[@]}" -gt 1 ]; then
	    srcport=""
	    while [ "${#ports[@]}" -gt 1 ]; do
		val="${ports[@]:0:7}"
		srcport="$srcport __mport__:${val// /,}"
		ports=("${ports[@]:7}")
	    done
	    srcport="$srcport ${ports[@]}"
	fi
    fi
    if [ "${FIREWALLY_USE_MPORT:-0}" != 0 -a "$dstport" != any ]; then
	ports=($dstport)
	if [ "${#ports[@]}" -gt 1 ]; then
	    dstport=""
	    while [ "${#ports[@]}" -gt 1 ]; do
		val="${ports[@]:0:7}"
		dstport="$dstport __mport__:${val// /,}"
		ports=("${ports[@]:7}")
	    done
	    dstport="$dstport ${ports[@]}"
	fi
    fi

    # Expand negative rules
    if [ -n "$ifacenot$ofacenot$srcnot$dstnot$protonot$srcportnot$dstportnot$icmptypenot$macnot$marknot$dscpnot$tosnot$servicenot" ]; then
	local oldchain="$_FWY_CHAIN"
	local _FWY_CHAIN

	# create dynamic chain
	while _fwy_chain_exists "${oldchain}_${_FWY_DYN_CHAIN}"; do
	    _FWY_DYN_CHAIN=$[_FWY_DYN_CHAIN + 1]
	done
	_FWY_CHAIN="${oldchain}_${_FWY_DYN_CHAIN}"
	_FWY_DYN_CHAIN=$[_FWY_DYN_CHAIN + 1]
	_fwy_create_chain "$_FWY_CHAIN" || return 1

	if [ -n "$ifacenot" ]; then
	    for aiface in $iface; do
		_fwy_iptables -i "$aiface" -j RETURN || return 1
	    done
	    iface=any
	fi
	if [ -n "$ofacenot" ]; then
	    for aoface in $oface; do
		_fwy_iptables -o "$aoface" -j RETURN || return 1
	    done
	    oface=any
	fi
	if [ -n "$srcnot" ]; then
	    for asrc in $src; do
		_fwy_iptables -s "$asrc" -j RETURN || return 1
	    done
	    src=any
	fi
	if [ -n "$dstnot" ]; then
	    for adst in $dst; do
		_fwy_iptables -d "$adst" -j RETURN || return 1
	    done
	    dst=any
	fi
	if [ -n "$srcportnot" ]; then
	    for aproto in $proto; do
		for asrcport in $srcport; do
		    case "$asrcport" in
			__mport__:*)
			    _fwy_iptables -p "$aproto" -m $FIREWALLY_MPORT_MATCH --sports "${asrcport#__mport__:}" -j RETURN || return 1
			    ;;
			*)
			    _fwy_iptables -p "$aproto" --sport "$asrcport" -j RETURN || return 1
			    ;;
		    esac
		done
	    done
	    srcport=any
	fi
	if [ -n "$dstportnot" ]; then
	    for aproto in $proto; do
		for adstport in $dstport; do
		    case "$adstport" in
			__mport__:*)
			    _fwy_iptables -p "$aproto" -m $FIREWALLY_MPORT_MATCH --dports "${adstport#__mport__:}" -j RETURN || return 1
			    ;;
			*)
			    _fwy_iptables -p "$aproto" --dport "$adstport" -j RETURN || return 1
			    ;;
		    esac
		done
	    done
	    dstport=any
	fi
	if [ -n "$icmptypenot" ]; then
	    for aicmptype in $icmptype; do
		_fwy_iptables -p icmp --icmp-type "$aicmptype" RETURN || return 1
	    done
	    icmptype=any
	fi
	if [ -n "$protonot" ]; then
	    for aproto in $proto; do
		_fwy_iptables -p "$aproto" -j RETURN || return 1
	    done
	fi
	if [ -n "$servicenot" ]; then
	    local dp
	    for aservice in $services; do
		case "$aservice" in
		    any)
			;;
		    tcp/* | udp/*)
			dp="${aservice#*/}"
			dp="${dp//[,;]/ }"
			dp="${dp:-any}"
			if [ "${FIREWALLY_USE_MPORT:-0}" != 0 -a "$dp" != any ]; then
			    ports=($dp)
			    if [ "${#ports[@]}" -gt 1 ]; then
				dp=""
				while [ "${#ports[@]}" -gt 1 ]; do
				    val="${ports[@]:0:7}"
				    dp="$dp __mport__:${val// /,}"
				    ports=("${ports[@]:7}")
				done
				dp="$dp ${ports[@]}"
			    fi
			fi
			for adstport in $dp; do
			    case "$adstport" in
				any)
				    _fwy_iptables -p "${aservice%%/*}" -j RETURN || return 1
				    ;;
				__mport__:*)
				    _fwy_iptables -p "${aservice%%/*}" -m $FIREWALLY_MPORT_MATCH \
					--dports "${adstport#__mport__:}" -j RETURN || return 1
				    ;;
			       *)
				    _fwy_iptables -p "${aservice%%/*}" --dport "$adstport" -j RETURN || return 1
				    ;;
		            esac
			done
			;;
		    icmp/*)
			dp="${aservice#*/}"
			dp="${dp//[,;]/ }"
			dp="${dp:-any}"
			for aicmptype in $dp; do
			    case "$aicmptype" in
				any)
				    _fwy_iptables -p icmp -j RETURN || return 1
				    ;;
				*)
				    _fwy_iptables -p icmp --icmp-type "$aicmptype" -j RETURN || return 1
				    ;;
			    esac
			done
			;;
		    *)
			_fwy_iptables -p "${aservice%%/*}" -j RETURN || return 1
			;;
		esac
	    done
	    services=any
	fi
	if [ -n "$macnot" ]; then
	    for amac in $mac; do
		_fwy_iptables -m mac --mac-source "$amac" -j RETURN || return 1
	    done
	    mac=any
	fi
	if [ -n "$marknot" ]; then
	    for amark in $mark; do
		_fwy_iptables -m mark --mark "$amark" -j RETURN || return 1
	    done
	    mark=any
	fi
	if [ -n "$dscpnot" ]; then
	    for adscp in $dscp; do
		_fwy_iptables -m dscp --dscp "$adscp" -j RETURN || return 1
	    done
	    dscp=any
	fi
	if [ -n "$tosnot" ]; then
	    for atos in $tos; do
		_fwy_iptables -m tos --tos "$atos" -j RETURN || return 1
	    done
	    tos=any
	fi

	if [ -n "$log" ]; then
	    # create logging rule
	    _fwy_iptables $log_match -j "$log" $log_args || return 1
	    log=
	fi

	# create action rules
	for aservice in $services; do
	    case "$aservice" in
		any)
		    ;;
		*/*)
		    proto="${aservice%%/*}"
		    ;;
	    esac
	    for aproto in $proto; do
		case "$aproto-$action-$action_args" in
		    any-*-*)
			_fwy_iptables -j "$action" $action_args || return 1
			;;
		    tcp-REJECT-)
			_fwy_iptables -p tcp -j REJECT --reject-with tcp-reset || return 1
			;;
		    *)
			_fwy_iptables -p "$aproto" -j "$action" $action_args || return 1
			;;
		esac
	    done
	done
	[ -n "$protonot$servicenot" ] && proto=any

	action="$_FWY_CHAIN" action_args= action_is_chain=1
	_FWY_CHAIN="$oldchain"
    fi

    # Expand rules
    for aiface in $iface; do
	case "$aiface" in
	    any) iface_arg=;;
	    !*)  iface_arg="-i ! ${aiface:1}";;
	    *)   iface_arg="-i $aiface";;
	esac

	for aoface in $oface; do
	    case "$aoface" in
		any) oface_arg=;;
	        !*)  oface_arg="-o ! ${aoface:1}";;
		*)   oface_arg="-o $aoface";;
	    esac

	    for asrc in $src; do
		case "$asrc" in
		    any) src_arg=;;
	            !*)  src_arg="-s ! ${asrc:1}";;
		    *)   src_arg="-s $asrc";;
		esac

		for adst in $dst; do
		    case "$adst" in
			any) dst_arg=;;
	                !*)  dst_arg="-d ! ${adst:1}";;
			*)   dst_arg="-d $adst";;
		    esac

		    for aservice in $services; do
			case "$aservice" in
			    any)
				;;
			    tcp/* | udp/*)
				proto="${aservice%%/*}"
				dstport="${aservice#*/}"
				dstport="${dstport//[,;]/ }"
				dstport="${dstport:-any}"
				icmptype=any
				if [ "${FIREWALLY_USE_MPORT:-0}" != 0 -a "$dstport" != any ]; then
				    ports=($dstport)
				    if [ "${#ports[@]}" -gt 1 ]; then
					dstport=""
					while [ "${#ports[@]}" -gt 1 ]; do
					    val="${ports[@]:0:7}"
					    dstport="$dstport __mport__:${val// /,}"
					    ports=("${ports[@]:7}")
					done
					dstport="$dstport ${ports[@]}"
				    fi
				fi
				;;
			    icmp/*)
				proto=icmp
				dstport=any
				icmptype="${aservice#*/}"
				icmptype="${icmptype//[,;]/ }"
				icmptype="${icmptype:-any}"
				;;
			    *)
				proto="${aservice%%/*}"
				dstport=any
				icmptype=any
				;;
			esac

			for aproto in $proto; do
			    case "$aproto" in
				any) proto_arg=;;
				!*)  proto_arg="-p ! ${aproto:1}";;
				*)   proto_arg="-p $aproto";;
			    esac

			    for aicmptype in $icmptype; do
				case "$aicmptype" in
				    any) icmptype_arg=;;
				    !*)  icmptype_arg="--icmp-type ! ${aicmptype:1}";;
				    *)   icmptype_arg="--icmp-type $aicmptype";;
				esac

				for asrcport in $srcport; do
				    case "$asrcport" in
					any) srcport_arg=;;
					__mport__:*) srcport_arg="-m $FIREWALLY_MPORT_MATCH --sports ${asrcport#__mport__:}";;
					!*)  srcport_arg="--sport ! ${asrcport:1}";;
					*)   srcport_arg="--sport $asrcport";;
				    esac

				    for adstport in $dstport; do
					case "$adstport" in
					    any) dstport_arg=;;
					    __mport__:*) dstport_arg="-m $FIREWALLY_MPORT_MATCH --dports ${adstport#__mport__:}";;
					    !*)  dstport_arg="--dport ! ${adstport:1}";;
					    *)   dstport_arg="--dport $adstport";;
					esac

					for amac in $mac; do
					    case "$amac" in
						any) mac_arg=;;
						!*)  mac_arg="-m mac ! --mac-source ${amac:1}";;
						*)   mac_arg="-m mac --mac-source $amac";;
					    esac

					    for amark in $mark; do
						case "$amark" in
						    any) mark_arg=;;
						    !*)  mark_arg="-m mark ! --mark ${amark:1}";;
						    *)   mark_arg="-m mark --mark $amark";;
						esac

						for adscp in $dscp; do
						    case "$adscp" in
							any) dscp_arg=;;
						        !*)  dscp_arg="-m dscp ! --dscp ${adscp:1}";;
							*)   dscp_arg="-m dscp --dscp $adscp";;
						    esac

						    for atos in $tos; do
							case "$atos" in
							    any) tos_arg=;;
						            !*)  tos_arg="-m tos ! --tos ${atos:1}";;
							    *)   tos_arg="-m tos --tos $atos";;
							esac

							case "$state" in
							    any) state_arg=;;
							    !*)  state_arg="-m state ! --state ${state:1}";;
							    *)   state_arg="-m state --state $state";;
							esac

							if [ -z "$limit" ]; then
							    limit_arg=
							elif [ -z "$limit_burst" ]; then
							    limit_arg="-m limit --limit $limit"
							else
							    limit_arg="-m limit --limit $limit --limit-burst $limit_burst"
							fi

							base_cmd="$iface_arg $oface_arg $src_arg $dst_arg \
							    $proto_arg $icmptype_arg $srcport_arg $dstport_arg \
							    $mac_arg $mark_arg $dscp_arg $tos_arg $state_arg \
							    $match $limit_arg"

							if [ -n "$log" ]; then
							    # create logging rule
							    _fwy_iptables $base_cmd $log_match -j "$log" $log_args || return 1
							fi

							# create rule
							if [ "$action-$action_args-$aproto" = "REJECT--tcp" ]; then
							    _fwy_iptables $base_cmd -j REJECT --reject-with tcp-reset || return 1
							else
							    _fwy_iptables $base_cmd -j "$action" $action_args || return 1
							fi
						    done
						done
					    done
					done
				    done
				done
			    done
			done
		    done
		done
	    done
	done
    done

    return 0
}

# }}}

# {{{ Commands

# version n
version()
{
    local _FWY_COMMAND="$FUNCNAME $@"

    if [ "$1" != "$_FWY_CONFIG_VERSION" ]; then
	_fwy_error "configuration version '$1' not supported"
	return 1
    fi
    return 0
}

# iptables args..
iptables()
{
    local _FWY_COMMAND="$FUNCNAME $@" _FWY_RULES=$_FWY_RULES_USER

    if [ "$1" = "-t" ]; then
	_fwy_valid_name table "$2" 30 || return 1
	local _FWY_TABLE="$2"
	shift 2
    fi
    if [ "$1" = "-A" ]; then
	_fwy_valid_name chain "$2" 30 || return 1
	local _FWY_CHAIN="$2"
	shift 2
    fi
    [ "$#" = 0 ] && _fwy_error "iptables requires arguments" && return 1

    # Initialize if not done already
    [ -d "${_FWY_TMP}/fw" ] || _fwy_initialize

    _fwy_iptables "$@"
}

# chain [table] name
chain()
{
    local _FWY_COMMAND="$FUNCNAME $@"
    local table="$_FWY_TABLE" chain

    if [ -n "$2" ]; then
	_fwy_valid_name table "$1" 30 || return 1
	table="$1"
	shift
    fi
    chain="$1"
    _fwy_valid_name chain "$chain" 20 || return 1

    # Initialize if not done already
    [ -d "${_FWY_TMP}/fw" ] || _fwy_initialize

    _FWY_TABLE="$table"
    _FWY_CHAIN="$chain"

    if ! _fwy_chain_exists "$chain"; then
	# Create chain
	_fwy_verbose "Creating chain '$chain' in table '$table'"
	[ "$_FWY_MODE" = explain ] && echo "iptables -t $table -N $chain"
	_fwy_create_chain "$chain"
    fi
}

# policy args...
policy()
{
    local _FWY_COMMAND="$FUNCNAME $@" _FWY_RULES=$_FWY_RULES_POLICY
    local args="$@"

    # Initialize if not done already
    [ -d "${_FWY_TMP}/fw" ] || _fwy_initialize

    : > "${_FWY_TMP}/fw/${_FWY_TABLE}/${_FWY_CHAIN}/r${_FWY_RULES}"
    if [ -n "$args" -a "$args" != return ]; then
        _fwy_rule "$@"
    fi
}

# rule args...
rule()
{
    local _FWY_COMMAND="$FUNCNAME $@" _FWY_RULES=$_FWY_RULES_USER
    _fwy_rule "$@"
}

log()
{
    local _FWY_COMMAND="$FUNCNAME $@" _FWY_RULES=$_FWY_RULES_USER
    _fwy_rule $FUNCNAME "$@"
}

loglimit()
{
    local _FWY_COMMAND="$FUNCNAME $@" _FWY_RULES=$_FWY_RULES_USER
    _fwy_rule $FUNCNAME "$@"
}

accept()
{
    local _FWY_COMMAND="$FUNCNAME $@" _FWY_RULES=$_FWY_RULES_USER
    _fwy_rule $FUNCNAME "$@"
}

drop()
{
    local _FWY_COMMAND="$FUNCNAME $@" _FWY_RULES=$_FWY_RULES_USER
    _fwy_rule $FUNCNAME "$@"
}

ret()
{
    local _FWY_COMMAND="$FUNCNAME $@" _FWY_RULES=$_FWY_RULES_USER
    _fwy_rule return "$@"
}

queue()
{
    local _FWY_COMMAND="$FUNCNAME $@" _FWY_RULES=$_FWY_RULES_USER
    _fwy_rule $FUNCNAME "$@"
}

jump()
{
    local _FWY_COMMAND="$FUNCNAME $@" _FWY_RULES=$_FWY_RULES_USER
    _fwy_rule $FUNCNAME "$@"
}

goto()
{
    local _FWY_COMMAND="$FUNCNAME $@" _FWY_RULES=$_FWY_RULES_USER
    _fwy_rule $FUNCNAME "$@"
}

reject()
{
    local _FWY_COMMAND="$FUNCNAME $@" _FWY_RULES=$_FWY_RULES_USER
    _fwy_rule $FUNCNAME "$@"
}

snat()
{
    local _FWY_COMMAND="$FUNCNAME $@" _FWY_RULES=$_FWY_RULES_USER
    _fwy_rule $FUNCNAME "$@"
}

dnat()
{
    local _FWY_COMMAND="$FUNCNAME $@" _FWY_RULES=$_FWY_RULES_USER
    _fwy_rule $FUNCNAME "$@"
}

masq()
{
    local _FWY_COMMAND="$FUNCNAME $@" _FWY_RULES=$_FWY_RULES_USER
    _fwy_rule $FUNCNAME "$@"
}

masquerade()
{
    local _FWY_COMMAND="$FUNCNAME $@" _FWY_RULES=$_FWY_RULES_USER
    _fwy_rule $FUNCNAME "$@"
}

redirect()
{
    local _FWY_COMMAND="$FUNCNAME $@" _FWY_RULES=$_FWY_RULES_USER
    _fwy_rule $FUNCNAME "$@"
}

setmark()
{
    local _FWY_COMMAND="$FUNCNAME $@" _FWY_RULES=$_FWY_RULES_USER
    _fwy_rule $FUNCNAME "$@"
}

settos()
{
    local _FWY_COMMAND="$FUNCNAME $@" _FWY_RULES=$_FWY_RULES_USER
    _fwy_rule $FUNCNAME "$@"
}

setdscp()
{
    local _FWY_COMMAND="$FUNCNAME $@" _FWY_RULES=$_FWY_RULES_USER
    _fwy_rule $FUNCNAME "$@"
}

imq()
{
    local _FWY_COMMAND="$FUNCNAME $@" _FWY_RULES=$_FWY_RULES_USER
    _fwy_rule $FUNCNAME "$@"
}

target()
{
    local _FWY_COMMAND="$FUNCNAME $@" _FWY_RULES=$_FWY_RULES_USER
    _fwy_rule $FUNCNAME "$@"
}

# service args...
# Shorthand for accept service args...
service()
{
    local _FWY_COMMAND="$FUNCNAME $@" _FWY_RULES=$_FWY_RULES_USER
    _fwy_rule accept $FUNCNAME "$@"
}

# protection args...
protection()
{
    local _FWY_COMMAND="$FUNCNAME $@" _FWY_RULES=$_FWY_RULES_USER
    local type="$1" rate="$2" burst="$3"
    local protections prot chain

    : "${burst:=20}"
    [ "$_FWY_TABLE" != filter ] && _fwy_error "protections only work in table 'filter'" && return 1

    # Initialize if not done already
    [ -d "${_FWY_TMP}/fw" ] || _fwy_initialize

    # Parse arguments
    for prot in ${type//[,;]/ }; do
	case "$prot" in
	    none | '')
		;;
	    strong | full | all)
		protections="$protections nosyn sfld bad inv ifld badi"
		;;
	    new-tcp-no-syn | new-tcp-w/o-syn)
		protections="$protections nosyn"
		;;
	    malformed | bad)
		protections="$protections bad"
		;;
	    invalid)
		[ "${FIREWALLY_STATEFUL:-0}" != 0 ] && protections="$protections inv"
		;;
	    bad-icmp | unsafe-icmp)
		protections="$protections badi"
		;;
	    syn-floods)
		protections="$protections sfld"
		;;
	    icmp-floods)
		protections="$protections ifld"
		;;
	    unroutable-src | unroutable-source)
		protections="$protections unrt_s"
		;;
	    unroutable-dst | unroutable-destination)
		protections="$protections unrt_d"
		;;
	    *)
		_fwy_error "unknown protection: '$prot'"
		return 1
		;;
	esac
    done

    # Record the location of the rules
    if [ -n "${_FWY_LINENO}" ]; then
	echo -e "#\n# source: ${FIREWALLY_CONFIG}:${_FWY_LINENO}\n# $_FWY_COMMAND" \
	    >> "${_FWY_TMP}/fw/$_FWY_TABLE/$_FWY_CHAIN/r$_FWY_RULES"
    fi

    # Process protections
    for prot in $protections; do
	chain="${_FWY_CHAIN}_${prot}"
	eval ": \${FIREWALLY_${_FWY_TABLE}_${chain}_POLICY:=drop loglimit}"
	case "$prot" in
	    nosyn)
		_fwy_chain_exists "$chain" || _fwy_create_chain "$chain" || return 1
		_fwy_iptables -p tcp ! --syn -m state --state NEW -j "$chain" || return 1
		;;
	    bad)
		_fwy_chain_exists "$chain" || _fwy_create_chain "$chain" || return 1
		local flags
		for flags in ALL:ALL ALL:NONE SYN,RST:SYN,RST ALL:SYN,RST,ACK,FIN,URG ALL:FIN,URG,PSH; do
		    _fwy_iptables -p tcp --tcp-flags "${flags%%:*}" "${flags##*:}" -j "$chain" || return 1
		done
		;;
	    inv)
		_fwy_chain_exists "$chain" || _fwy_create_chain "$chain" || return 1
		_fwy_iptables -m state --state INVALID -j "$chain" || return 1
		;;
	    badi)
		_fwy_chain_exists "$chain" || _fwy_create_chain "$chain" || return 1
		local t
		for t in ${UNSAFE_ICMP//,/ }; do
		    _fwy_iptables -p icmp --icmp-type "$t" -j "$chain" || return 1
		done
		;;
	    sfld)
		if ! _fwy_chain_exists "$chain"; then
		    _fwy_create_chain "$chain" || return 1
		    _FWY_CHAIN="$chain" _fwy_iptables -m limit \
			--limit "${rate:-$FIREWALLY_SYNFLOOD_LIMIT}" \
			--limit-burst "$burst" -j RETURN || return 1
		fi
		_fwy_iptables -p tcp --syn -j "$chain" || return 1
		;;
	    ifld)
		if ! _fwy_chain_exists "$chain"; then
		    _fwy_create_chain "$chain" || return 1
		    _FWY_CHAIN="$chain" _fwy_iptables -m limit \
			--limit "${rate:-$FIREWALLY_ICMPFLOOD_LIMIT}" \
			--limit-burst "$burst" -j RETURN || return 1
		fi
		_fwy_iptables -p icmp -j "$chain" || return 1
		;;
	    unrt_s | unrt_d)
		_fwy_chain_exists unroutable || _fwy_create_chain unroutable || return 1
		local ip
		for ip in ${UNROUTABLE_IPS//[,;]/ }; do
		    _fwy_iptables "-${prot#unrt_}" "$ip" -j unroutable || return 1
		done
		;;
	esac
    done

    return 0
}

# zone name spec...
zone()
{
    local _FWY_COMMAND="$FUNCNAME $@"
    local _FWY_TABLE=filter _FWY_RULES=$_FWY_RULES_ZONE_SEL
    local zone="$1" z2 defs def iface addr var

    # Validate arguments
    shift
    case "$zone" in
	fw | any)
	    _fwy_error "zone '$zone' is a built-in zone" && return 1
	    ;;
	*)
	    _fwy_valid_name zone "$zone" 10 || return 1
	    ;;
    esac
    [ -n "$_FWY_ZONES_INIT" ] && _fwy_error "cannot specify more zones" && return 1
    var="_FWY_ZONE_${zone}"
    case " $_FWY_ZONES " in
	*" $zone "*)
	    _fwy_warning "overriding zone: '$zone' becomes '$@'"
	    ;;
    esac

    # Initialize if not done already
    [ -d "${_FWY_TMP}/fw" ] || _fwy_initialize

    # Parse spec
    _fwy_verbose "Creating zone '$zone'"
    if [ $# = 0 ]; then
	defs="any:any"
    else
	for def; do
	    case "$def" in
		*:*)
		    iface="${def%%:*}" addr="${def#*:}"
		    ;;
		*.*)
		    iface= addr="$def"
		    ;;
		*)
		    iface="$def" addr=
		    ;;
	    esac
	    defs="$defs ${iface:-any}:${addr:-any}"
	done
    fi

    # Remember spec
    eval "${var}=\"\$defs\""

    # Add rules to standard chains
    local _FWY_CHAIN
    eval ": \${FIREWALLY_filter_${zone}_to_fw_POLICY:=\$FIREWALLY_filter_INPUT_POLICY}"
    eval ": \${FIREWALLY_filter_fw_to_${zone}_POLICY:=\$FIREWALLY_filter_OUTPUT_POLICY}"
    eval ": \${FIREWALLY_filter_fwd_${zone}_POLICY:=\"drop loglimit\"}"
    for def in $defs; do
	iface="${def%%:*}" addr="${def#*:}"
	_FWY_CHAIN=INPUT
	_fwy_rule goto "${zone}_to_fw" iface "$iface" saddr "$addr" || return 1
	_FWY_CHAIN=OUTPUT
	_fwy_rule goto "fw_to_${zone}" oface "$iface" daddr "$addr" || return 1
	_FWY_CHAIN=FORWARD
	_fwy_rule goto "fwd_${zone}"   iface "$iface" saddr "$addr" || return 1
    done

    # Link the new zone to the old ones
    for z2 in $_FWY_ZONES; do
	_FWY_CHAIN="fwd_${z2}"
	eval ": \${FIREWALLY_filter_${z2}_to_${zone}_POLICY:=\$FIREWALLY_filter_FORWARD_POLICY}"
	for def in $defs; do
	    _fwy_rule goto "${z2}_to_${zone}" oface "${def%%:*}" daddr "${def#*:}" || return 1
	done
    done

    # Link old zones from the new one
    _FWY_CHAIN="fwd_${zone}"
    for z2 in $_FWY_ZONES $zone; do
	var="_FWY_ZONE_${z2}"
	eval ": \${FIREWALLY_filter_${zone}_to_${z2}_POLICY:=\$FIREWALLY_filter_FORWARD_POLICY}"
	for def in ${!var}; do
	    _fwy_rule goto "${zone}_to_${z2}" oface "${def%%:*}" daddr "${def#*:}" || return 1
	done
    done

    _FWY_ZONES="$_FWY_ZONES $zone"
    return 0
}

# from zone [to] zone
from()
{
    local _FWY_COMMAND="$FUNCNAME $@"
    local z1="$1" z2 chain z

    # Parse and validate arguments
    shift
    [ "$1" = to ] && shift
    z2="$1"
    case " $_FWY_ZONES " in
	*" $z1 "*) ;;
	*)
	    case "$z1" in
	    	fw | any) ;;
		*) _fwy_error "unknown 'from' zone: '$z1'" && return 1;;
	    esac
	    ;;
    esac
    case " $_FWY_ZONES " in
	*" $z2 "*) ;;
	*)
	    case "$z2" in
	    	fw | any) ;;
		*) _fwy_error "unknown 'to' zone: '$z2'" && return 1;;
	    esac
	    ;;
    esac

    _fwy_verbose "Processing rules from '$z1' to '$z2'"
    chain="${z1}_to_${z2}"
    _FWY_TABLE=filter
    case "$chain" in
	any_to_* | *_to_any)
	    _FWY_ZONES_INIT=1
	    eval "FIREWALLY_filter_${chain}_POLICY="
	    ;;
	*)
	    eval ": \${FIREWALLY_filter_${chain}_POLICY:=drop loglimit}"
	    ;;
    esac
    # Handle special cases
    case "$chain" in
	fw_to_fw)
	    _fwy_error "cannot filter from '$z1' to '$z2'"
	    return 1
	    ;;
	any_to_any)
	    if ! _fwy_chain_exists any_to_any; then
		local _FWY_RULES=$_FWY_RULES_ZONE_ANY1
		_fwy_create_chain any_to_any || return 1
		for _FWY_CHAIN in INPUT FORWARD OUTPUT; do
		    _fwy_iptables -j any_to_any || return 1
		done
	    fi
	    ;;
	any_to_fw | fw_to_any)
	    if ! _fwy_chain_exists $chain; then
		local _FWY_RULES=$_FWY_RULES_ZONE_ANY2
		_fwy_create_chain $chain || return 1
		if [ "$chain" = any_to_fw ]; then
		    _FWY_CHAIN=INPUT
		else
		    _FWY_CHAIN=OUTPUT
		fi
		_fwy_iptables -j $chain || return 1
	    fi
	    ;;
	*_to_any)
	    if ! _fwy_chain_exists $chain; then
		local _FWY_RULES=$_FWY_RULES_ZONE_ANY2
		_fwy_create_chain $chain || return 1
		_FWY_CHAIN="${z1}_to_fw" _fwy_iptables -j $chain || return 1
		_FWY_CHAIN="fwd_${z1}" _fwy_iptables -j $chain || return 1
	    fi
	    ;;
	any_to_*)
	    if ! _fwy_chain_exists $chain; then
		local _FWY_RULES=$_FWY_RULES_ZONE_ANY2
		_fwy_create_chain $chain || return 1
		for z in fw $_FWY_ZONES; do
		    _FWY_CHAIN="${z}_to_${z2}" _fwy_iptables -j $chain || return 1
		done
	    fi
	    ;;
    esac

    _FWY_CHAIN="$chain"
    return 0
}

# mac interface ip mac
mac()
{
    local _FWY_COMMAND="$FUNCNAME $@"

    [ -d "${_FWY_TMP}/fw" ] || _fwy_initialize
    local _FWY_TABLE=filter _FWY_CHAIN _FWY_RULES=$_FWY_RULES_MAC

    if ! _fwy_chain_exists check_mac; then
	FIREWALLY_filter_check_mac_POLICY=
	_fwy_create_chain check_mac || return 1
	_fwy_create_chain mac_invalid || return 1
	if [ "${FIREWALLY_STATEFUL:-0}" != 0 ]; then
	    _FWY_CHAIN=INPUT
	    _fwy_iptables -m state --state NEW -j check_mac || return 1
	    _FWY_CHAIN=FORWARD
	    _fwy_iptables -m state --state NEW -j check_mac || return 1
	else
	    _FWY_CHAIN=INPUT
	    _fwy_iptables -j check_mac || return 1
	    _FWY_CHAIN=FORWARD
	    _fwy_iptables -j check_mac || return 1
	fi
    fi
    _FWY_CHAIN=check_mac
    _fwy_rule goto mac_invalid iface "$1" src "$2" mac "!$3"
}

# postprocess command ...
postprocess()
{
    echo "$@" >> "${_FWY_TMP}/post"
}

# }}}

# {{{ Main

# _fwy_cleanup
# Trap handler: remove temporary directory
_fwy_cleanup()
{
    local rc=$?

    if [ -n "$_FWY_TMP" -a "$_FWY_TMP" != "/" ]; then
	${_FWY_RM_CMD} -rf "${_FWY_TMP}"
    fi
}

# _fwy_interrupt
# Trap handler: cleanup
_fwy_interrupt()
{
    _FWY_MODE= _FWY_USING_IPTABLES=
    _fwy_error "Interrupted"
}

# _fwy_usage
# Show program usage
_fwy_usage()
{
    cat >&2 <<EOF
Usage: $0 [configfile] [argument]

Arguments:
    start        Activate firewall configuration
    try		 Activate firewall, wait until user types "commit"
    stop	 Stop a running firewall
    clear
    restart	 Activate firewall configuration
    reload
    status	 Show the running firewall
    panic	 Block all IP communication
    debug	 Show resulting rules
    explain	 Enter interactive mode
    interactive
    <filename>   Configuration file (default: $FIREWALLY_CONFIG)

Options:
    verbose	 Verbose execution
    help	 Show this help

FireWally $FIREWALLY_VERSION ($FIREWALLY_REVISION), by tavy@ylabs.com

EOF
}

# Process arguments
while [ "$#" -gt 0 ]; do
    case "$1" in
	start | run | restart | reload)
	    _FWY_MODE=start
	    ;;
	try)
	    _FWY_MODE=try
	    ;;
	stop | clear)
	    _FWY_MODE=stop
	    ;;
	panic)
	    _FWY_MODE=panic
	    ;;
	debug)
	    _FWY_MODE=debug
	    ;;
	explain | interactive)
	    _FWY_MODE=explain
	    ;;
	status | show)
	    _FWY_MODE=status
	    ;;
	verbose | -v | --verbose)
	    _FWY_VERBOSE=1
	    ;;
	version | --version)
	    echo "FireWally $FIREWALLY_VERSION ($FIREWALLY_REVISION), by tavy@ylabs.com"
	    exit 0
	    ;;
	help | -h | --help)
	    _fwy_usage
	    exit 0
	    ;;
	*)
	    if [ -e "$1" ]; then
		FIREWALLY_CONFIG="$1"
		: "${_FWY_MODE:=try}"
	    else
		echo >&2 "firewally: Unknown argument '$1'"
		_fwy_usage
		exit 1
	    fi
	    ;;
    esac
    shift
done

if [ -z "$_FWY_MODE" ]; then
    _fwy_usage
    exit 1
fi

# Locate required commands
_fwy_find_cmd _FWY_AWK_CMD gawk awk
_fwy_find_cmd _FWY_CAT_CMD cat
_fwy_find_cmd _FWY_IPTABLES_CMD iptables
_fwy_find_cmd _FWY_IPTABLES_RESTORE_CMD iptables-restore
_fwy_find_cmd _FWY_IPTABLES_SAVE_CMD iptables-save
_fwy_find_cmd _FWY_LESS_CMD less more
_fwy_find_cmd _FWY_LOGGER_CMD logger true
_fwy_find_cmd _FWY_LSMOD_CMD lsmod echo
_fwy_find_cmd _FWY_MKDIR_CMD mkdir
_fwy_find_cmd _FWY_MKTEMP_CMD mktemp
_fwy_find_cmd _FWY_MODPROBE_CMD modprobe insmod false
_fwy_find_cmd _FWY_RM_CMD rm
_fwy_find_cmd _FWY_TOUCH_CMD touch

# Easy commands
case "$_FWY_MODE" in
    status)
	# Show running firewall
	if [ -f /proc/net/ip_tables_names ]; then
	    for table in $(sort /proc/net/ip_tables_names); do
		echo
		echo "--- $table ---------------------------------------------------------------------"
		echo
		${_FWY_IPTABLES_CMD} -t "$table" -nvL
	    done | ${_FWY_LESS_CMD}
	else
	    echo "Firewall not running."
	fi
	exit 0
	;;

    stop)
	# Stop firewall
	echo -n "firewally: Stopping firewall: "
	if [ ! -f /proc/net/ip_tables_names ]; then
	    echo "done"
	    exit 0
	fi
	if _fwy_clear "" ACCEPT; then
	    ${_FWY_LOGGER_CMD} -t firewally -p local5.info "Stopping firewall: ok"
	    echo "done"
	    exit 0
	else
	    ${_FWY_LOGGER_CMD} -t firewally -p local5.err "Stopping firewall: FAILED"
	    echo "FAILED"
	    exit 1
	fi
	;;

    panic)
	# Block firewall
	echo -n "firewally: Blocking firewall${SSH_CLIENT:+, allowing access from $SSH_CLIENT}: "
	# ensure the filter table is loaded
	${_FWY_IPTABLES_CMD} -t filter -nvL INPUT >/dev/null
	if _fwy_clear "" DROP "$SSH_CLIENT"; then
	    ${_FWY_LOGGER_CMD} -t firewally -p local5.info "Blocking firewall${SSH_CLIENT:+, allowing access from $SSH_CLIENT}: ok"
	    echo "done"
	    exit 0
	else
	    ${_FWY_LOGGER_CMD} -t firewally -p local5.err "Blocking firewall${SSH_CLIENT:+, allowing access from $SSH_CLIENT}: ok"
	    echo "FAILED"
	    exit 1
	fi
	;;
esac

# Initialize working environment
_FWY_TMP=`${_FWY_MKTEMP_CMD} -d ${TMPDIR:-/tmp}/fwy.XXXXXX` || _fwy_fatal "cannot create temporary directory"
trap _fwy_cleanup EXIT
trap _fwy_interrupt INT TERM
_FWY_OLD_FW="${_FWY_TMP}/old.fw"
_FWY_NEW_FW="${_FWY_TMP}/new.fw"

# Check if the mport iptables match is available
if [ -z "$FIREWALLY_USE_MPORT" -o -z "$FIREWALLY_MPORT_MATCH" ]; then
    if ${_FWY_AWK_CMD} "BEGIN { split(\"`uname -r`\", a, /[^0-9]/); exit(a[2]<6 || (a[2]==6 && a[3]<14)) }" \
        && _fwy_match_exists multiport; then
	FIREWALLY_USE_MPORT=1
	: "${FIREWALLY_MPORT_MATCH:=multiport}"
    elif _fwy_match_exists mport; then
	FIREWALLY_USE_MPORT=1
	: "${FIREWALLY_MPORT_MATCH:=mport}"
    else
	FIREWALLY_USE_MPORT=0
	: "${FIREWALLY_MPORT_MATCH:=multiport}"
    fi
fi

if [ "$_FWY_MODE" = explain ]; then
    # Interactive mode
    FIREWALLY_CONFIG="Interactive User Input"
    _FWY_LINENO=1
    _FWY_NEW_CONF="${_FWY_TMP}/new.conf"
    trap "exit 0" INT TERM

    echo "version $_FWY_CONFIG_VERSION" > "${_FWY_NEW_CONF}"
    echo "FireWally -- Interactive Mode"

    while :; do
	read -p "FireWally [$_FWY_TABLE:$_FWY_CHAIN]> " -e
	[ -z "$REPLY" ] && continue
	set -- ${REPLY}
	case "$1" in
	    help)
		${_FWY_CAT_CMD} <<EOF
You can use anything a FireWally configuration file accepts, including variables,
loops, etc. Take only care to write loops in one row.
Additionaly, you can use the following commands:

    help    print this text on your screen
    show    show all the successfull commands so far
    quit    show the interactively given configuration file and quit
    in      same as typing: zone net eth0; from net to fw

EOF
		;;
	    show)
		echo
		echo "--------------------------------------------------"
		${_FWY_CAT_CMD} "${_FWY_NEW_CONF}"
		echo "--------------------------------------------------"
		;;
	    quit | exit)
		if [ "$_FWY_LINENO" -gt 1 ]; then
		    echo
		    echo "--------------------------------------------------"
		    ${_FWY_CAT_CMD} "${_FWY_NEW_CONF}"
		    echo "--------------------------------------------------"
		fi
		exit 0
	        ;;
	    *)
		[ "$1" = "in" ] && set -- zone net eth0\; from net to fw
		eval "$@"
		if [ $? -gt 0 ]; then
		    printf "\n# FAILED\n"
		else
		    case "$1" in
			chain | zone | from | mac | *=*)
			    echo >> "${_FWY_NEW_CONF}"
			    ;;
			*)
			    echo -n "    " >> "${_FWY_NEW_CONF}"
			    ;;
		    esac
		    echo "$@" >> "${_FWY_NEW_CONF}"
		    _FWY_LINENO=$[_FWY_LINENO + 1]
		fi
		;;
	esac
    done
fi

if [ "$_FWY_MODE" != debug ]; then
    echo -n "firewally: Starting firewall: "
    ${_FWY_LOGGER_CMD} -t firewally -p local5.info "Starting firewall"
    [ -n "$_FWY_VERBOSE" ] && echo

    # Save old firewall
    _fwy_verbose "Saving old firewall"
    ${_FWY_TOUCH_CMD} "${_FWY_OLD_FW}"
    if [ -f /proc/net/ip_tables_names ]; then
	_fwy_iptables_save -c > "${_FWY_OLD_FW}" || _fwy_fatal "cannot save current firewall"
    fi
    if ${_FWY_AWK_CMD} '/^\*filter/ { exit(1) }' "${_FWY_OLD_FW}"; then
	${_FWY_CAT_CMD} >> "${_FWY_OLD_FW}" <<EOF
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
COMMIT
EOF
    fi
fi

# Add line number information
_fwy_verbose "Preprocessing source"
[ -e "$FIREWALLY_CONFIG" ] || _fwy_fatal "configuration file '$FIREWALLY_CONFIG' does not exist"
[ -r "$FIREWALLY_CONFIG" ] || _fwy_fatal "cannot read configuration file '$FIREWALLY_CONFIG'"

${_FWY_AWK_CMD} "/^[[:space:]]*(accept|chain|dnat|drop|from|goto|imq|iptables|jump|log|loglimit\
|mac|masq|masquerade|policy|postprocess|protection|queue|redirect|reject|ret|rule|service|setdscp\
|setmark|settos|snat|target|version|zone)\\>/ \
{ printf \"_FWY_LINENO=%d; \", NR }
{ print }" "$FIREWALLY_CONFIG" > "${_FWY_TMP}/source.config" || \
    _fwy_fatal "cannot convert source file"

# Execute configuration
_fwy_verbose "Executing configuration"
enable -n trap
enable -n exit
source "${_FWY_TMP}/source.config" || _fwy_fatal "cannot execute configuration"
enable trap
enable exit

if [ -n "$FIREWALLY_UNCONFIGURED" ]; then
    if [ "$_FWY_MODE" = start ]; then
	${_FWY_LOGGER_CMD} -t firewally -p local5.info "Starting firewall: not configured"
	echo "not configured"
    else
	_fwy_error "firewall is unconfigured"
    fi
    exit 1
fi

# Configuration OK, generate rules
[ -d "${_FWY_TMP}/fw" ] || _fwy_initialize
_fwy_verbose "Generating rules"
echo -e "# iptables-save file generated by FireWally $FIREWALLY_VERSION\n#" >"${_FWY_NEW_FW}"
for tabledir in "${_FWY_TMP}/fw"/*; do
    table="${tabledir##*/}"
    echo "*$table"
    for chaindir in "$tabledir"/*; do
	chain="${chaindir##*/}"
	echo ":$chain -"
    done
    ${_FWY_CAT_CMD} "$tabledir"/*/r* || _fwy_fatal "cannot create rules"
    echo "COMMIT"
done >> "${_FWY_NEW_FW}" || _fwy_fatal "cannot create rules"


if [ "$_FWY_MODE" = debug ]; then
    # Show the generated firewall
    if [ -t 1 ]; then
	${_FWY_LESS_CMD} "${_FWY_NEW_FW}"
    else
	${_FWY_CAT_CMD} "${_FWY_NEW_FW}"
    fi
    exit 0
fi

# Activate!
if [ ! -f /proc/net/ip_tables_names ]; then
    _fwy_verbose "Loading ip_tables module"
    ${_FWY_MODPROBE_CMD} ip_tables || _fwy_fatal "inserting module 'ip_tables' failed"
fi

rc=1
if [ "${FIREWALLY_USE_IPTABLES_RESTORE:-0}" != 0 ]; then
    # Try iptables-restore
    _fwy_verbose "Activating firewall with iptables-restore"
    _fwy_load_restore && rc=0
fi
if [ "$rc" -ne 0 ]; then
    # Try iptables
    _fwy_verbose "Activating firewall with iptables"
    _fwy_load_iptables && rc=0
    [ "$rc" = 0 -a "${FIREWALLY_USE_IPTABLES_RESTORE:-0}" != 0 ] && \
	_fwy_warning "Activation failed with iptables-restore, but succeeded with iptables"
fi
if [ "$rc" -ne 0 ]; then
    ${_FWY_LOGGER_CMD} -t firewally -p local5.err "Starting firewall: FAILED"
    echo "FAILED"

    echo -n "firewally: Restoring old firewall: "
    if ${_FWY_IPTABLES_RESTORE_CMD} < "${_FWY_OLD_FW}"; then
	echo "done"
    else
	# We're screwed
	echo "FAILED"
    fi
    exit 3
fi

# Set up routing
if [ -n "$FIREWALLY_ROUTING" ]; then
    _fwy_verbose "Setting up routing"
    echo "$FIREWALLY_ROUTING" > /proc/sys/net/ipv4/ip_forward
fi

# Load connection-tracking / nat modules
_fwy_verbose "Loading kernel conntrack/nat modules"
modules=
modules_skip=`${_FWY_LSMOD_CMD} | ${_FWY_AWK_CMD} '/^(ip|nf)_(conntrack|nat)_/ { printf "%s ", $1 }'`
moddir=/lib/modules/$(uname -r)/kernel/net/ipv4/netfilter
for module in $FIREWALLY_MODULES; do
    case "$module" in
	all | ALL)
	    if [ "${FIREWALLY_STATEFUL:-0}" != 0 ]; then
		# List conntrack modules
		for mod in $moddir/{ip,nf}_conntrack_*.*; do
		    [ -f "$mod" ] || continue
		    basemod="${mod##*/}"
		    modules="$modules ${basemod%%.*}"
		done
		# List nat modules if the firewall has the "nat" table
		if [ -d "${_FWY_TMP}/fw/nat" ]; then
		    for mod in $moddir/{ip,nf}_nat_*.*; do
			[ -f "$mod" ] || continue
			basemod="${mod##*/}"
			modules="$modules ${basemod%%.*}"
		    done
		fi
	    fi
	    ;;
	-*)
	    mod="${module%%.*}"
	    modules_skip="$modules_skip ${mod:1}"
	    ;;
	*)
	    modules="$modules ${module%%.*}"
	    ;;
    esac
done
for module in $modules; do
    case " $modules_skip " in
	*" $module "*)
	    ;;
	*)
	    ${_FWY_MODPROBE_CMD} "$module"
	    ;;
    esac
done

# run postprocess commands
if [ -f "${_FWY_TMP}/post" ]; then
    _fwy_verbose "Running postprocess commands"
    source "${_FWY_TMP}/post"
fi

echo "done"
${_FWY_LOGGER_CMD} -t firewally -p local5.info "Starting firewall: ok"

if [ "$_FWY_MODE" = try ]; then
    # Ask whether to keep the firewall
    read -p "Keep the firewall? (type 'commit' to accept - 30 seconds timeout): " -t 30 -e
    ret=$?
    echo
    if [ $ret -ne 0 -o "${REPLY}" != commit ]; then
	echo -n "firewally: Restoring old firewall: "
	if ${_FWY_IPTABLES_RESTORE_CMD} < "${_FWY_OLD_FW}"; then
	    ${_FWY_LOGGER_CMD} -t firewally -p local5.info "Restoring old firewall: ok"
	    echo "done"
	    exit 0
	else
	    ${_FWY_LOGGER_CMD} -t firewally -p local5.info "Restoring old firewall: FAILED"
	    echo "FAILED"
	    exit 3
	fi
    fi
fi

exit 0

# }}}
